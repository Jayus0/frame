# 重试策略使用说明

## 概述

重试策略模块提供了灵活的服务调用重试机制，支持指数退避、固定延迟和线性增长三种重试策略。当服务调用失败时，系统会自动根据配置的重试策略进行重试，提高系统的稳定性和可靠性。

## 功能特性

- ✅ **多种重试策略**：固定延迟、指数退避、线性增长
- ✅ **可配置重试次数**：支持为每个服务配置不同的重试次数
- ✅ **智能错误判断**：可配置哪些错误可重试，哪些不可重试
- ✅ **自动延迟计算**：根据重试策略自动计算延迟时间
- ✅ **与熔断器集成**：与现有的熔断器机制配合工作

## 重试策略类型

### 1. 固定延迟（Fixed）
每次重试使用相同的延迟时间。

**示例：**
- 初始延迟：100ms
- 第1次重试：延迟100ms
- 第2次重试：延迟100ms
- 第3次重试：延迟100ms

### 2. 指数退避（Exponential）
延迟时间按指数增长，这是最常用的重试策略。

**示例：**
- 初始延迟：100ms，退避乘数：2.0
- 第1次重试：延迟100ms (100 * 2^0)
- 第2次重试：延迟200ms (100 * 2^1)
- 第3次重试：延迟400ms (100 * 2^2)
- 第4次重试：延迟800ms (100 * 2^3)

### 3. 线性增长（Linear）
延迟时间线性增长。

**示例：**
- 初始延迟：100ms
- 第1次重试：延迟200ms (100 * 2)
- 第2次重试：延迟300ms (100 * 3)
- 第3次重试：延迟400ms (100 * 4)

## 使用方法

### 基本使用

```cpp
#include "eagle/core/Framework.h"
#include "eagle/core/ServiceRegistry.h"
#include "eagle/core/RetryPolicy.h"

using namespace Eagle::Core;

// 获取框架实例
Framework* framework = Framework::instance();
framework->initialize();

// 获取服务注册表
ServiceRegistry* serviceRegistry = framework->serviceRegistry();

// 配置重试策略
RetryPolicyConfig config;
config.maxRetries = 3;                    // 最大重试3次
config.initialDelayMs = 100;              // 初始延迟100ms
config.maxDelayMs = 5000;                 // 最大延迟5秒
config.backoffMultiplier = 2.0;           // 退避乘数2.0
config.strategy = RetryStrategy::Exponential;  // 使用指数退避

// 为特定服务设置重试策略
serviceRegistry->setRetryPolicy("UserService", config);

// 调用服务（自动应用重试策略）
QVariant result = serviceRegistry->callService("UserService", "getUser", args);
```

### 配置错误类型

可以指定哪些错误可重试，哪些不可重试：

```cpp
RetryPolicyConfig config;
config.maxRetries = 3;
config.strategy = RetryStrategy::Exponential;

// 指定可重试的错误类型
config.retryableErrors << "timeout" << "network" << "connection";

// 指定不可重试的错误类型
config.nonRetryableErrors << "permission" << "not found" << "invalid";

serviceRegistry->setRetryPolicy("UserService", config);
```

### 启用/禁用重试

```cpp
// 启用重试（默认启用）
serviceRegistry->setRetryEnabled(true);

// 禁用重试
serviceRegistry->setRetryEnabled(false);

// 检查重试是否启用
bool enabled = serviceRegistry->isRetryEnabled();
```

### 获取重试策略

```cpp
// 获取服务的重试策略
RetryPolicyConfig config = serviceRegistry->getRetryPolicy("UserService");

qDebug() << "最大重试次数:" << config.maxRetries;
qDebug() << "重试策略:" << static_cast<int>(config.strategy);
```

## 配置示例

### 示例1：快速重试（固定延迟）

适用于对延迟敏感的场景：

```cpp
RetryPolicyConfig config;
config.maxRetries = 2;
config.initialDelayMs = 50;
config.maxDelayMs = 200;
config.strategy = RetryStrategy::Fixed;

serviceRegistry->setRetryPolicy("FastService", config);
```

### 示例2：标准重试（指数退避）

适用于大多数场景：

```cpp
RetryPolicyConfig config;
config.maxRetries = 3;
config.initialDelayMs = 100;
config.maxDelayMs = 5000;
config.backoffMultiplier = 2.0;
config.strategy = RetryStrategy::Exponential;

serviceRegistry->setRetryPolicy("StandardService", config);
```

### 示例3：保守重试（线性增长）

适用于需要逐步增加延迟的场景：

```cpp
RetryPolicyConfig config;
config.maxRetries = 5;
config.initialDelayMs = 200;
config.maxDelayMs = 10000;
config.strategy = RetryStrategy::Linear;

serviceRegistry->setRetryPolicy("ConservativeService", config);
```

## 错误处理

### 默认行为

默认情况下，以下错误类型会被认为是可重试的：
- `timeout` - 超时错误
- `network` - 网络错误
- `connection` - 连接错误

其他错误默认也可重试，除非在 `nonRetryableErrors` 列表中。

### 自定义错误判断

```cpp
RetryPolicyConfig config;
config.maxRetries = 3;

// 只重试超时和网络错误
config.retryableErrors << "timeout" << "network";

// 不重试权限和验证错误
config.nonRetryableErrors << "permission" << "unauthorized" << "forbidden";

serviceRegistry->setRetryPolicy("SecureService", config);
```

## 日志输出

重试过程中会输出详细的日志：

```
[INFO] ServiceRegistry: 重试服务调用: UserService::getUser (第2次, 延迟200ms)
[INFO] ServiceRegistry: 服务调用成功（重试2次）: UserService::getUser
```

## 与熔断器的配合

重试策略与熔断器机制配合工作：

1. **熔断器开启时**：如果熔断器处于Open状态，不会进行重试，直接返回错误
2. **重试失败后**：每次重试失败都会记录到熔断器，可能触发熔断
3. **重试成功后**：成功调用会记录到熔断器，有助于熔断器恢复

## 性能考虑

1. **延迟时间**：合理设置延迟时间，避免过长的等待
2. **重试次数**：根据服务特性设置重试次数，避免无限重试
3. **最大延迟**：设置合理的最大延迟，防止延迟时间过长

## 最佳实践

1. **超时错误**：通常应该重试，因为可能是临时网络问题
2. **权限错误**：通常不应该重试，因为重试不会改变结果
3. **资源不存在**：通常不应该重试，除非是临时性问题
4. **验证错误**：通常不应该重试，因为重试不会改变结果

## 注意事项

1. **同步调用**：当前实现是同步重试，重试期间会阻塞线程
2. **返回值**：重试成功后返回最后一次成功调用的返回值
3. **性能监控**：重试次数和延迟时间会影响性能监控数据
4. **日志记录**：所有重试操作都会记录到日志中

## 配置参数说明

| 参数 | 类型 | 说明 | 默认值 |
|------|------|------|--------|
| maxRetries | int | 最大重试次数（0表示不重试） | 3 |
| initialDelayMs | int | 初始延迟（毫秒） | 100 |
| maxDelayMs | int | 最大延迟（毫秒） | 5000 |
| backoffMultiplier | double | 退避乘数（指数退避使用） | 2.0 |
| strategy | RetryStrategy | 重试策略类型 | Exponential |
| retryableErrors | QStringList | 可重试的错误类型列表 | 空（所有错误可重试） |
| nonRetryableErrors | QStringList | 不可重试的错误类型列表 | 空 |

## 示例代码

完整示例：

```cpp
#include "eagle/core/Framework.h"
#include "eagle/core/ServiceRegistry.h"

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);
    
    // 初始化框架
    Framework* framework = Framework::instance();
    framework->initialize();
    
    ServiceRegistry* registry = framework->serviceRegistry();
    
    // 配置重试策略
    RetryPolicyConfig retryConfig;
    retryConfig.maxRetries = 3;
    retryConfig.initialDelayMs = 100;
    retryConfig.maxDelayMs = 5000;
    retryConfig.backoffMultiplier = 2.0;
    retryConfig.strategy = RetryStrategy::Exponential;
    retryConfig.retryableErrors << "timeout" << "network";
    retryConfig.nonRetryableErrors << "permission" << "not found";
    
    registry->setRetryPolicy("UserService", retryConfig);
    
    // 调用服务（自动应用重试策略）
    QVariantList args;
    args << "user123";
    QVariant result = registry->callService("UserService", "getUser", args);
    
    if (result.isValid()) {
        qDebug() << "调用成功:" << result;
    } else {
        qDebug() << "调用失败（已重试）";
    }
    
    return 0;
}
```
